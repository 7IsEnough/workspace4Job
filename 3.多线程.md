# 多线程

35. **并行和并发有什么区别？**

    - 并行是指两个或多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
    - 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
    - 在一台处理器上“同时”处理多个任务，在多台处理器上“同时”处理多个任务。如 hadoop 分布式集群。

    所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

36. **线程与进程的区别？**

    简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。

37. **守护线程是什么？**

    守护线程 （即 daemon thread），是个服务线程，准确地来说就是服务其他的线程。

38. **创建线程有哪几种方式？**
    1. 继承 Thread 类创建线程类
       - 定义 Thread 类的子类，并重写该类的 run 方法，该 run 方法的方法体就代表了线程要完成的任务。因此把 run() 方法称为执行体。
       - 创建 Thread 线程子类的实例，即创建了线程对象。
       - 调用线程对象的 start() 方法来启用该线程。
    2. 通过 Runnable 接口创建线程类
       - 定义 Runnable 接口的实现类，并重写该接口的 run() 方法，该 run() 方法的方法体同样是该线程的线程执行体。
       - 创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。
       - 调用线程对象的 start() 方法来启用该线程。
    3. 通过 Callable 和 Future 创建线程
       - 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
       - 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
       - 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
       - 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

39. **说一下 runnable 和 callable 有什么区别？**

    - Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹的去执行 run() 方法中的代码而已；
    - Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。

40. **线程有哪些状态?**

    线程通常有五种状态，创建、就绪、运行、阻塞和死亡。

    - 创建状态。在生成线程对象，并没有调用该对象的 start 方法，这时线程处于创建状态。
    - 就绪状态。当调用了线程对象的 start 方法后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
    - 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行 run 函数当中的代码。
    - 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep、suspend、wait 等方法都可以导致线程阻塞。
    - 死亡状态。如果一个线程的 run 方法执行结束或者调用 stop 方法后，该线程就会死亡。对于已经死亡的线程，无法再使用 start 方法令其进入就绪。





​	

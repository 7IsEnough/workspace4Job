# 多线程

35. **并行和并发有什么区别？**

    - 并行是指两个或多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
    - 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
    - 在一台处理器上“同时”处理多个任务，在多台处理器上“同时”处理多个任务。如 hadoop 分布式集群。

    所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

36. **线程与进程的区别？**

    简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。

37. **守护线程是什么？**

    守护线程 （即 daemon thread），是个服务线程，准确地来说就是服务其他的线程。

38. **创建线程有哪几种方式？**
    1. 继承 Thread 类创建线程类
       - 定义 Thread 类的子类，并重写该类的 run 方法，该 run 方法的方法体就代表了线程要完成的任务。因此把 run() 方法称为执行体。
       - 创建 Thread 线程子类的实例，即创建了线程对象。
       - 调用线程对象的 start() 方法来启用该线程。
    2. 通过 Runnable 接口创建线程类
       - 定义 Runnable 接口的实现类，并重写该接口的 run() 方法，该 run() 方法的方法体同样是该线程的线程执行体。
       - 创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。
       - 调用线程对象的 start() 方法来启用该线程。
    3. 通过 Callable 和 Future 创建线程
       - 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
       - 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
       - 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
       - 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

39. **说一下 runnable 和 callable 有什么区别？**

    - Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹的去执行 run() 方法中的代码而已；
    - Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。

40. **线程有哪些状态?**

    线程通常有五种状态，创建、就绪、运行、阻塞和死亡。

    - 创建状态。在生成线程对象，并没有调用该对象的 start 方法，这时线程处于创建状态。
    - 就绪状态。当调用了线程对象的 start 方法后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
    - 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行 run 函数当中的代码。
    - 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep、suspend、wait 等方法都可以导致线程阻塞。
    - 死亡状态。如果一个线程的 run 方法执行结束或者调用 stop 方法后，该线程就会死亡。对于已经死亡的线程，无法再使用 start 方法令其进入就绪。

41. **sleep() 和 wait() 有什么区别？**

    sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争 CPU 的执行时间。因为 sleep() 是 static 静态方法，他不能改变对象的机锁，当一个 synchronized 块中调用了 sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。

    wait()：wait() 是 Object 类的方法，当一个线程执行到 wait 方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过 notify，notifyAll 方法唤醒等待的线程。

42. **notify() 和 notifyAll() 有什么区别？**

    - 如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
    - 当有线程调用了对象的 notifyAll() 方法（唤醒所有 wait 线程）或 notify() 方法（只随机唤醒一个 wait 线程），被唤醒的线程变回进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了 notify 后只有一个线程会由等待池进入锁池，而 notifyAll 会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。
    - 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait() 方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 

43. **线程的 run() 和 start() 有什么区别？**

    每个线程都是通过某个特定 Thread 对象所对应的方法 run() 来完成其操作的，方法 run() 称为线程体。通过调用 Thread 类的 start() 方法来启动一个线程。

    start() 方法来启动一个线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码；这时此线程是处于就绪状态，并没有运行。然后通过此 Thread 类调用方法 run() 来完成其运行状态，这里方法 run() 称为线程体，它包含了要执行的这个线程的内容，run 方法运行结束，此线程终止。然后 CPU 再调度其它线程。

    run() 方法是在本线程里的，只是线程里的一个函数，而不是多线程的。如果直接调用 run() ，其实就相当于是调用了一个普通函数而已，直接调用 run() 方法必须等待 run() 方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特涨，所以在多线程执行时要使用 start() 方法而不是 run() 方法。





​	
